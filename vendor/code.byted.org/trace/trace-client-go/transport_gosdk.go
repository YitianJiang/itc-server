package trace

import (
	"sync"
	"sync/atomic"

	"code.byted.org/gopkg/logs"
	"code.byted.org/gopkg/thrift"
	"code.byted.org/log_market/gosdk"
	"code.byted.org/trace/trace-client-go/jaeger-client"
	"code.byted.org/trace/trace-client-go/jaeger-client/utils"
	j "code.byted.org/trace/trace-client-go/jaeger-client/thrift-gen/jaeger"
	"github.com/pkg/errors"
	"math"
)

const (
	defaultTaskName = "opentracing"
)

var defaultTags = map[string]string{
	"_data_fmt": "tracing",
	"_protocol": "thrift",
	"_psm":      "toutiao.unknown.unknown",
}

var globalLimiter = &spanSendLimiter{
	opsLimiter: make(map[string]*upperBoundSender),
	defaultLimiter: &upperBoundSender{
		upperBound: 0.0,
	},
}

type gosdkSender struct {
	// These fields must be first in the struct because `sync/atomic` expects 64-bit alignment.
	// Cf. https://github.com/golang/go/issues/13868
	closed int64 // 0 - not closed, 1 - closed

	sync.Mutex
	taskName       string     // task name for gosdk send api
	process        *j.Process // process info
	serializerPool sync.Pool
}

// NewGosdkTransport creates a reporter that submits spans to jaeger-agent
func NewGosdkTransport(taskName string) (jaeger.Transport, error) {
	if taskName == "" {
		taskName = defaultTaskName
	}

	sender := &gosdkSender{
		taskName: taskName,
		serializerPool: sync.Pool{New: func() interface{} {
			return thrift.NewTSerializer()
		}},
	}
	return sender, nil
}

func (s *gosdkSender) Append(span *jaeger.Span) (int, error) {
	if s.process == nil {
		s.Lock()
		if s.process == nil {
			s.process = jaeger.BuildJaegerProcessThrift(span)
			defaultTags["_psm"] = s.process.ServiceName
		}
		s.Unlock()
	}
	if globalLimiter.IsBlock(span) {
		return 1, errors.Errorf("hited upperBound block logic")
	}
	jSpan := jaeger.BuildJaegerThrift(span)
	serializer := s.serializerPool.Get().(*thrift.TSerializer)
	defer s.serializerPool.Put(serializer)

	data, err := serializer.Write(jSpan)
	if err != nil {
		logs.Warn("serialize for span generated by %s::%s failed.",
			s.process.ServiceName, jSpan.OperationName)
		return 1, err
	}

	// TODO(zhanggongyuan): add extra tags for dispatch
	msg := &gosdk.Msg{
		Msg:  data,
		Tags: defaultTags,
	}
	if err = gosdk.Send(s.taskName, msg); err != nil {
		logs.Warn("gosdk send msg for %s::%s failed",
			s.process.ServiceName, jSpan.OperationName)
		return 1, err
	}

	return 1, nil
}

func (s *gosdkSender) Flush() (int, error) {
	return 0, nil
}

func (s *gosdkSender) Close() error {
	if swapped := atomic.CompareAndSwapInt64(&s.closed, 0, 1); !swapped {
		return errors.Errorf("repeated attempt to close the sender is ignored")
	}
	_, err := s.Flush()
	gosdk.GracefullyExit()

	return err
}

// -----------------------

type upperBoundSender struct {
	upperBound float64
	rateLimiter utils.RateLimiter
}

// spanSendLimiter used to control span reporting qps
type spanSendLimiter struct {
	sync.RWMutex

	opsLimiter map[string]*upperBoundSender
	defaultLimiter *upperBoundSender
}

func (l *spanSendLimiter) IsBlock(span *jaeger.Span) bool {
	l.RLock()
	defer l.RUnlock()

	limiter, exists := l.opsLimiter[span.OperationName()]
	if !exists {
		limiter = l.defaultLimiter
	}
	if limiter.upperBound > 0.0 && limiter.rateLimiter != nil {
		return !limiter.rateLimiter.CheckCredit(1.0)
	}

	return false
}

func (l *spanSendLimiter) update(upperBound float64, opsLimiter map[string]*upperBoundSender) {
	l.Lock()
	defer l.Unlock()

	l.opsLimiter = opsLimiter
	if upperBound != l.defaultLimiter.upperBound && upperBound >= 0.0 {
		l.defaultLimiter = newUpperBoundSender(upperBound)
	}
}

func newUpperBoundSender(upperBound float64) *upperBoundSender {
	return &upperBoundSender{
		upperBound: upperBound,
		rateLimiter: utils.NewRateLimiter(upperBound, math.Max(upperBound, 1.0)),
	}
}
